---
title: "Suits Index"
author: "Andie Creel"
date: 'September, 2022'
output: 
  html_document:
    number_sections: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE, message=FALSE}
rm(list = ls())
library(vroom)
library(tidyr)
library(stringr)
library(ggplot2)
library(gtools)
library(forcats)
options(scipen=99999)
library(janitor)
library(dplyr)
library(zoo)
library(runner)
source('09.functions.R')
library(fixest)
library(kableExtra)

# ----maps ---- #
library(choroplethr)
library(choroplethrMaps)
library(usdata)
library(maps)
library(tidycensus)
data("fips_codes")
data("state.regions")
library(RColorBrewer)


```

Thanks to Matt Ashenfarb for providing helpful code on the suites index. 
```{r, include=FALSE, message=FALSE}
#-------------------------------------------------------------------------------
# Basic data cleaning
# Grant amounts are already adjusted for inflation, adjusting median income (2018 dollars)
#-------------------------------------------------------------------------------

# made in 01.data_wrangle.R
myWorking <- vroom("Datasets/clean_data/lwcf_annualPop_deccenialDemographics.csv") 

#Basic data cleaning
myWorking <- myWorking %>%
  mutate(type = str_sub(type,0,1)) %>% #getting rid of a space 
  mutate(state_fips = as.factor(str_sub(fips, 1, 2))) %>% # getting state fips code
  filter(!is.na(white_pct)) %>% # getting rid of rows where I couldn't get their demographic data
  dplyr::mutate(poc_pct = 100 - white_pct) %>% # calculating % people of color as non-hispanic white
  mutate(amount = if_else(is.na(amount), 0, amount)) %>%  # adding 0s for amount of grant rewarded
  filter(type != "P") # not including planning grants bc they're given to states, not counties

# working years: 1965-2018
myWorking %>%
  select(real_year) %>%
  distinct() %>%
  summary()

```

# Set Up and Definitions 

The **outcomes of interest** is how the amount of LWCF funds and quantity of grants are distributed across demographic characteristics of interest. 

Originally I used two different per capita measurements for the amount of LWCF funds and quantity of grants.

1. Funds (or quantity of grants) given to a county  divided by the population of the county at the time of LWCF distribution. This captures how the program was administered through time.
2. The cumulative amount of funds (or quantity of grants) given to a county from 1965-2018 divided by the population of the county in 2020 (estimates for population of each county is not available for each county in 2018 in the American Community Survey). This captures how individuals today are effected by the LWCF program.

After both per capita metrics returned similar results (stored in commit from Sept 20th, 2022), I used the first definition which can be interpreted as how the program has been administered historically. 

I use per capita metrics for amount of funding and quantity of grants to control for a county's population. 

## Demographics of Interest (x axis)
We are interested in the distribution of funds across three county-level demographic characteristics: median income, % POC, % rural. 

**Average median household income**: the median household income (averaged from 1965-2018 for each county). 

**Average percent people of color**: the percent of people in a color who are not non-Hispanic white (averaged from 1965-2018 for each county). 

**Average percent rural**: the percent of people consider living in a rural district??/cbg?? need to check census definition of rural. (averaged from 1965-2018 for each county). 

**Average Wealth Proxy: Zillow Home Value Index**: the average price of a typical home smoothed, seasonally adjusted measure of the typical home value for homes in the 35th to 65th percentile range (2018$). 

## Comparing of Suits Index across states 
We can compare the level of "regressivity" or "progressivity" (i.e., suits index) across states. For example, we could say Michigan is more progressive with its LWCF funds than Texas in regards to income. 

However, two states with different income distributions could have the same suits index. For example, Michigan and New Mexico may have different wealth distributions (ie Michigan is on average richer than New Mexico) but have the same suits index.  

## The sign of the suits index 
Suits indices are traditionally used to evaluate if a **tax** is progressive or regressive. A positive suits index is a progressive tax. The suits index is **typically** calculated as [(area under the neutral line) - (area under Lorenz curve)] / (area under the neutral line). 

The LWCF is a **subsidy** program. To keep signs consistent with "progressive" or "regressive" **I calculated the suits index as [(area under  Lorenz curve) - (area under the neutral line)] / (area under the neutral line)**.

**A positive suits index in our study indicates a progressive subsidy (least privileged get helped the most). A negative suits index indicates a regressive subsidy.**

```{r, echo=FALSE}

#-------------------------------------------------------------------------------
#per cap: per cap through time aka how it's been implemented through time
#-------------------------------------------------------------------------------

myWorking_per_cap <- myWorking %>%
    mutate(amount_per_cap = amount / population) %>% # amount per capita each year
    mutate(quantity_per_cap = got_grant/ population) %>% #  quantity per capita each year
    group_by(fips) %>% # group by county
    mutate(amount_per_cap_cum = sum(amount_per_cap)) %>% # cumulative amount per cap
    mutate(quantity_per_cap_cum = sum(quantity_per_cap)) %>% # cumulative quantity per cap
    mutate(avg_med_income_house = mean(med_income_house, na.rm = TRUE)) %>% #average median income
    mutate(avg_poc_pct = mean(poc_pct, na.rm = TRUE)) %>%
    mutate(avg_rural_pct = mean(rural_pct, na.rm = TRUE)) %>%
    select(state_fips, fips, amount_per_cap_cum, quantity_per_cap_cum, avg_med_income_house, avg_poc_pct, avg_rural_pct) %>% # set up reduce down to one entry per county
    distinct() # reduce

#-------------------------------------------------------------------------------
# Merging in ZHDI, getting average ZHDI through time for each county 
#-------------------------------------------------------------------------------
myZHVI_og <- vroom("Datasets/clean_data/annual_ZHVI.csv")

#avg through time
myZHVI <- myZHVI_og %>%
  group_by(fips) %>%
  mutate(ZHVI = mean(annual_ZHVI, na.rm = TRUE)) %>%
  select(fips, ZHVI) %>%
  distinct()
rm(myZHVI_og)

myWorking_per_cap <- left_join(myWorking_per_cap, myZHVI, by = "fips")

```

# Income 

## Nation Picture

```{r, echo=FALSE, message=FALSE}

#-------------------------------------------------------------------------------
# results for nation 
#-------------------------------------------------------------------------------

myResult <- getSuits(myWorking_per_cap, x_axis = "Income")
printSuits(myResult, x_axis = "Income")
```

Interpretation note: makes sense that it's more progressive in quantity of grants administered than in amount of funds because of matching. We'd expect poorer counties to get smaller grants because they have less access to money for matching. 

I believe this. 

## State by State Picture

```{r, echo=FALSE, message=FALSE}
#-------------------------------------------------------------------------------
# results for states
# DATA PREP
#-------------------------------------------------------------------------------

fips_codes <- fips_codes %>%
  select(state_code) %>%
  distinct()

#Gets list of dataframes for each state (applys function to whole list of state fips)
state_dfs <- lapply(as.character(fips_codes$state_code), function(st=x){
                      df <- myWorking_per_cap  %>%
                        filter(state_fips == st) %>%
                        mutate(state_fips = as.character(state_fips))
                      return(df)
                      }) 


#get a data frame of suits results using function written earlier and list of state dataframes
myResult_state <- data.frame(matrix(ncol=3, nrow = length(state_dfs)))
colnames(myResult_state) <- c("state_fips", "Suits_Amount", "Suits_Quantity" )
for (i in 1:length(state_dfs)) {
  myResult_state[i, 1] <- state_dfs[[i]][1,1] #state fips
   myResult_state[i, 2] <- getSuits(state_dfs[[i]])$Suits_Amount
     myResult_state[i, 3] <- getSuits(state_dfs[[i]])$Suits_Quantity

}

# drop clean up state_fips codes
myResult_state <- myResult_state %>%
  mutate(state_fips = str_pad(state_fips, width = 2, pad ="0")) %>%
  mutate(state_fips = as.character(state_fips))

```


### Amount of Funds 


```{r, echo=FALSE}
#-------------------------------------------------------------------------------
# Make choropleth map of state results for suits index for amount of funding
#-------------------------------------------------------------------------------

# state_choropleth doesn't work for all fips codes, so we need to only use those in data(state.regions)
myMap_amount <- left_join(state.regions, myResult_state, by = c("fips.character" = "state_fips")) %>%
  mutate(value = Suits_Amount) %>% #for state_choropleth map call
  mutate(value = if_else(is.na(value), 0, value)) %>% #so that we don't have NAs in map
  filter()

#rewrote the state_choropleth function a bit to get rid of state label
myState_choropleth(myMap_amount, num_colors = 0, legend = "Suits Index" ) +  #num_colors = 0 makes it so white is zero
  ggtitle(label = "Suits indexes varries state to state despite being progessive nationally",
          subtitle =  "Amount of funding per capita compared to avg. median household income (aggregated at county level)") +
  theme(legend.position="bottom")



```

### Quantity of Grants

```{r, echo=FALSE}
#-------------------------------------------------------------------------------
# Make choropleth map of state results for suits index for quantity of grants
# same code as above with my revisous 
#-------------------------------------------------------------------------------

myMap_quantity <- left_join(state.regions, myResult_state, by = c("fips.character" = "state_fips")) %>%
  mutate(value = Suits_Quantity) %>% #REVISION
  mutate(value = if_else(is.na(value), 0, value)) %>% 
  filter()

myState_choropleth(myMap_quantity, num_colors = 0, legend = "Suits Index" ) +  
  ggtitle(label = "Suits indexes for quantity of grants is progessive in most states",
          subtitle =  "Quantity of grants per capita compared to avg. median household income (aggregated at county level)") +
  theme(legend.position="bottom") 

```


# Wealth Proxy: Zillow Home Value Index 

## Nation Picture

```{r, echo=FALSE, message=FALSE}

#-------------------------------------------------------------------------------
# results for nation 
#-------------------------------------------------------------------------------
myResult_wealth <- getSuits(myWorking_per_cap, x_axis = "Wealth")
printSuits(myResult_wealth, x_axis = "Wealth")
```

Interpretation note: typical home value nor income is explaining the discrimination we see in POC 

## State by State Picture

```{r, echo=FALSE, message=FALSE}

#get a data frame of suits results using function written earlier and list of state dataframes
myResult_state_wealth <- data.frame(matrix(ncol=3, nrow = length(state_dfs)))
colnames(myResult_state_wealth) <- c("state_fips", "Suits_Amount", "Suits_Quantity" )
for (i in 1:length(state_dfs)) {
  myResult_state_wealth[i, 1] <- state_dfs[[i]][1,1] #state fips
   myResult_state_wealth[i, 2] <- getSuits(state_dfs[[i]], x_axis = "Wealth")$Suits_Amount
     myResult_state_wealth[i, 3] <- getSuits(state_dfs[[i]], x_axis = "Wealth")$Suits_Quantity

}

# drop clean up state_fips codes
myResult_state_wealth <- myResult_state_wealth %>%
  mutate(state_fips = str_pad(state_fips, width = 2, pad ="0")) %>%
  mutate(state_fips = as.character(state_fips))

```


### Amount of Funds 


```{r, echo=FALSE}
#-------------------------------------------------------------------------------
# Make choropleth map of state results for suits index for amount of funding
#-------------------------------------------------------------------------------

# state_choropleth doesn't work for all fips codes, so we need to only use those in data(state.regions)
myMap_amount_wealth <- left_join(state.regions, myResult_state_wealth, by = c("fips.character" = "state_fips")) %>%
  mutate(value = Suits_Amount) %>% #for state_choropleth map call
  mutate(value = if_else(is.na(value), 0, value)) %>% #so that we don't have NAs in map
  filter()

#rewrote the state_choropleth function a bit to get rid of state label
myState_choropleth(myMap_amount_wealth, num_colors = 0, legend = "Suits Index" ) +  #num_colors = 0 makes it so white is zero
  ggtitle(label = "Suits indexes varries state to state despite being progessive nationally",
          subtitle =  "Amount of funding per capita compared to typical home value (aggregated at county level)") +
  theme(legend.position="bottom")



```

### Quantity of Grants

```{r, echo=FALSE}
#-------------------------------------------------------------------------------
# Make choropleth map of state results for suits index for quantity of grants
# same code as above with my revisous 
#-------------------------------------------------------------------------------

myMap_quantity_wealth <- left_join(state.regions, myResult_state_wealth, by = c("fips.character" = "state_fips")) %>%
  mutate(value = Suits_Quantity) %>% #REVISION
  mutate(value = if_else(is.na(value), 0, value)) %>% 
  filter()

myState_choropleth(myMap_quantity_wealth, num_colors = 0, legend = "Suits Index" ) +  
  ggtitle(label = "Suits indexes for quantity of grants is progessive in most states",
          subtitle =  "Quantity of grants per capita compared to typical home value (aggregated at county level)") +
  theme(legend.position="bottom") 

```





# Population of Color

## National Picture 

```{r, echo=FALSE}

myResult_poc <- getSuits(myWorking_per_cap, x_axis = "POC")
printSuits(myResult_poc, x_axis = "POC")

```

## State-by-State Picture 

```{r, echo=FALSE, message=FALSE}
#-------------------------------------------------------------------------------
# results for states
# DATA PREP
#-------------------------------------------------------------------------------

#get a data frame of suits results using function written earlier and list of state dataframes
myResult_state_poc <- data.frame(matrix(ncol=3, nrow = length(state_dfs)))
colnames(myResult_state_poc) <- c("state_fips", "Suits_Amount", "Suits_Quantity" )
for (i in 1:length(state_dfs)) {
  myResult_state_poc[i, 1] <- state_dfs[[i]][1,1] #state fips
   myResult_state_poc[i, 2] <- getSuits(state_dfs[[i]], x_axis = "POC")$Suits_Amount
     myResult_state_poc[i, 3] <- getSuits(state_dfs[[i]], x_axis = "POC")$Suits_Quantity

}

# drop clean up state_fips codes
myResult_state_poc <- myResult_state_poc %>%
  mutate(state_fips = str_pad(state_fips, width = 2, pad ="0")) %>%
  mutate(state_fips = as.character(state_fips))

```

### Amount of Funds 


```{r, echo=FALSE}
#-------------------------------------------------------------------------------
# Make choropleth map of state results for suits index for amount of funding
#-------------------------------------------------------------------------------

# state_choropleth doesn't work for all fips codes, so we need to only use those in data(state.regions)
myMap_amount_poc <- left_join(state.regions, myResult_state_poc, by = c("fips.character" = "state_fips")) %>%
  mutate(value = Suits_Amount) %>% #for state_choropleth map call
  mutate(value = if_else(is.na(value), 0, value)) %>% #so that we don't have NAs in map
  filter()

#rewrote the state_choropleth function a bit to get rid of state label
myState_choropleth(myMap_amount_poc, num_colors = 0, legend = "Suits Index" ) +  #num_colors = 0 makes it so white is zero
  ggtitle(label = "Suits indexes are regressive when it comes to amount of funds for people of color",
          subtitle =  "Amount of funding per capita compared to avg. % poc (aggregated at county level)") +
  theme(legend.position="bottom")



```

### Quantity of Grants

```{r, echo=FALSE}
#-------------------------------------------------------------------------------
# Make choropleth map of state results for suits index for quantity of grants
# same code as above with my revisions 
#-------------------------------------------------------------------------------

myMap_quantity_poc <- left_join(state.regions, myResult_state_poc, by = c("fips.character" = "state_fips")) %>%
  mutate(value = Suits_Quantity) %>% #REVISION
  mutate(value = if_else(is.na(value), 0, value)) %>% 
  filter()

myState_choropleth(myMap_quantity_poc, num_colors = 0, legend = "Suits Index" ) +  
  ggtitle(label = "Suits indexes are regressive when it comes quantity received by people of color",
          subtitle =  "Quantity of grants per capita compared to avg. % of POC (aggregated at county level)") +
  theme(legend.position="bottom") 

```

# Rural

## National Picture 

```{r, echo=FALSE}

myResult_rural <- getSuits(myWorking_per_cap, x_axis = "Rural")
printSuits(myResult_rural, x_axis = "Rural")

```

## State-by-State Picture 

```{r, echo=FALSE, message=FALSE}
#-------------------------------------------------------------------------------
# results for states
# DATA PREP
#-------------------------------------------------------------------------------

#get a data frame of suits results using function written earlier and list of state dataframes
myResult_state_rural <- data.frame(matrix(ncol=3, nrow = length(state_dfs)))
colnames(myResult_state_rural) <- c("state_fips", "Suits_Amount", "Suits_Quantity" )
for (i in 1:length(state_dfs)) {
  myResult_state_rural[i, 1] <- state_dfs[[i]][1,1] #state fips
   myResult_state_rural[i, 2] <- getSuits(state_dfs[[i]], x_axis = "Rural")$Suits_Amount
     myResult_state_rural[i, 3] <- getSuits(state_dfs[[i]], x_axis = "Rural")$Suits_Quantity

}

# drop clean up state_fips codes
myResult_state_rural <- myResult_state_rural %>%
  mutate(state_fips = str_pad(state_fips, width = 2, pad ="0")) %>%
  mutate(state_fips = as.character(state_fips))

```

### Amount of Funds 


```{r, echo=FALSE}
#-------------------------------------------------------------------------------
# Make choropleth map of state results for suits index for amount of funding
#-------------------------------------------------------------------------------

# state_choropleth doesn't work for all fips codes, so we need to only use those in data(state.regions)
myMap_amount_rural <- left_join(state.regions, myResult_state_rural, by = c("fips.character" = "state_fips")) %>%
  mutate(value = Suits_Amount) %>% #for state_choropleth map call
  mutate(value = if_else(is.na(value), 0, value)) %>% #so that we don't have NAs in map
  filter()

#rewrote the state_choropleth function a bit to get rid of state label
myState_choropleth(myMap_amount_rural, num_colors = 0, legend = "Suits Index" ) +  #num_colors = 0 makes it so white is zero
  ggtitle(label = "Suits indexes are somewhat progressive for amount of funds to rural counties",
          subtitle =  "Amount of funding per capita compared to avg. % rural (aggregated at county level)") +
  theme(legend.position="bottom")



```

### Quantity of Grants

```{r, echo=FALSE}
#-------------------------------------------------------------------------------
# Make choropleth map of state results for suits index for quantity of grants
# same code as above with my revisions 
#-------------------------------------------------------------------------------

myMap_quantity_rural <- left_join(state.regions, myResult_state_rural, by = c("fips.character" = "state_fips")) %>%
  mutate(value = Suits_Quantity) %>% #REVISION
  mutate(value = if_else(is.na(value), 0, value)) %>% 
  filter()

myState_choropleth(myMap_quantity_rural, num_colors = 0, legend = "Suits Index" ) +  
  ggtitle(label = "Suits indexes are mixed for quantity received by rural counties",
          subtitle =  "Quantity of grants per capita compared to avg. % rural (aggregated at county level)") +
  theme(legend.position="bottom") 

```




# Regressions 

## Amount

```{r, echo = FALSE}

#-------------------------------------------------------------------------------
# regressions with the exact same dataset used for the suits indices
#-------------------------------------------------------------------------------


one <- feols(data = myWorking_per_cap, amount_per_cap_cum ~  avg_poc_pct)
two <- feols(data = myWorking_per_cap, amount_per_cap_cum ~  avg_poc_pct + avg_rural_pct)
three <- feols(data = myWorking_per_cap, amount_per_cap_cum ~  avg_poc_pct + avg_rural_pct + avg_med_income_house)
four <- feols(data = myWorking_per_cap, amount_per_cap_cum ~  avg_poc_pct + avg_rural_pct + avg_med_income_house + ZHVI)
five <- feols(data = myWorking_per_cap, amount_per_cap_cum ~  avg_poc_pct + avg_rural_pct + avg_med_income_house + ZHVI | state_fips)

etable(one,
       two,
       three,
       four,
       five,
       signifCode = c("***"=0.01, "**"=0.05, "*"=0.10)) %>%
  kbl(booktabs = T, caption = "Race") %>%
  kable_styling(latex_options = c("scale_down","HOLD_position")) 

#include a variable for political affiliation? 
# county size ??

#-------------------------------------------------------------------------------
# not cumulative per person, we're keeping year in this 
#-------------------------------------------------------------------------------

myWorking_not_cumulative <- myWorking %>%
    mutate(amount_per_cap = amount / population) %>% # amount per capita each year
    mutate(quantity_per_10000 = (got_grant/ population)*10000) %>%
  select(amount_per_cap, quantity_per_10000, med_income_house, poc_pct, rural_pct, state_fips, year) %>%
  distinct()

one.t <- feols(data = myWorking_not_cumulative, amount_per_cap ~  poc_pct)
two.t <- feols(data = myWorking_not_cumulative, amount_per_cap ~  poc_pct + rural_pct)
three.t <- feols(data = myWorking_not_cumulative, amount_per_cap ~  poc_pct + rural_pct + med_income_house)
# four.t <- feols(data = myWorking_not_cumulative, amount_per_cap ~  poc_pct + rural_pct + med_income_house + ZHVI)
five.t <- feols(data = myWorking_not_cumulative, amount_per_cap ~  poc_pct + rural_pct + med_income_house | state_fips)
six.t <- feols(data = myWorking_not_cumulative, amount_per_cap ~  poc_pct + rural_pct + med_income_house | state_fips + year)

etable(one.t,
       two.t,
       three.t,
       # four.t,
       five.t,
       six.t,
       signifCode = c("***"=0.01, "**"=0.05, "*"=0.10)) %>%
  kbl(booktabs = T, caption = "Race") %>%
  kable_styling(latex_options = c("scale_down","HOLD_position")) 


```

## Quantity 
```{r, echo = FALSE}

#-------------------------------------------------------------------------------
# regressions with the exact same dataset used for the suits indices
#-------------------------------------------------------------------------------

myWorking_per_cap.reg <- myWorking_per_cap %>%
  mutate(quantity_per_10000_cum = quantity_per_cap_cum*10000)

one <- feols(data = myWorking_per_cap.reg, quantity_per_10000_cum ~  avg_poc_pct)
two <- feols(data = myWorking_per_cap.reg, quantity_per_10000_cum ~  avg_poc_pct + avg_rural_pct)
three <- feols(data = myWorking_per_cap.reg, quantity_per_10000_cum ~  avg_poc_pct + avg_rural_pct + avg_med_income_house)
four <- feols(data = myWorking_per_cap.reg, quantity_per_10000_cum ~  avg_poc_pct + avg_rural_pct + avg_med_income_house + ZHVI)
five <- feols(data = myWorking_per_cap.reg, quantity_per_10000_cum ~  avg_poc_pct + avg_rural_pct + avg_med_income_house + ZHVI | state_fips)

etable(one,
       two,
       three,
       four,
       five,
       signifCode = c("***"=0.01, "**"=0.05, "*"=0.10)) %>%
  kbl(booktabs = T, caption = "Race") %>%
  kable_styling(latex_options = c("scale_down","HOLD_position")) 

#include a variable for political affiliation? 
# county size ??

#-------------------------------------------------------------------------------
# not cumulative per person, we're keeping year in this 
#-------------------------------------------------------------------------------


one.t <- feols(data = myWorking_not_cumulative, quantity_per_10000 ~  poc_pct)
two.t <- feols(data = myWorking_not_cumulative, quantity_per_10000 ~  poc_pct + rural_pct)
three.t <- feols(data = myWorking_not_cumulative, quantity_per_10000 ~  poc_pct + rural_pct + med_income_house)
# four.t <- feols(data = myWorking_not_cumulative, quantity_per_cap ~  poc_pct + rural_pct + med_income_house + ZHVI)
five.t <- feols(data = myWorking_not_cumulative, quantity_per_10000 ~  poc_pct + rural_pct + med_income_house | state_fips)
six.t <- feols(data = myWorking_not_cumulative, quantity_per_10000 ~  poc_pct + rural_pct + med_income_house | state_fips + year)

etable(one.t,
       two.t,
       three.t,
       # four.t,
       five.t,
       six.t,
       signifCode = c("***"=0.01, "**"=0.05, "*"=0.10)) %>%
  kbl(booktabs = T, caption = "Race") %>%
  kable_styling(latex_options = c("scale_down","HOLD_position")) 


```


# Conclusions 

* LWCF seems pretty progressive with regards to income 
* LWCF seems very regression when it comes to % POC. This matches up with what we say in the quartile study.
* LWCF seems pretty neutral when we look at the differences between rural and urban counties. At the very least, the limited invest in counties with a high % POC is not explained by them being urban and most money going to rural states, otherwise the POC and Rural maps would look more similar. 


